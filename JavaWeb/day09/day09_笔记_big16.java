今日内容大纲:
	多线程:
		概述:
		多线程并行和并发的区别:
		多线程的实现方式:
			方式一: 继承Thread类.
			
			方式二: 实现Runnable接口.
		案例: 
			//模拟卖票(100张票, 分4个窗口)
			//基础实现
			//发现问题
				出现重复票:
				出现负数票: 
			//解决问题
				同步
		多线程的生命周期:	
		
		扩展内容:
			同步详解:
			匿名内部类:
			死锁:
			多线程的生命周期:
		
	
	网络编程:
		概述:
		网络模型:
		三大要素:
			IP:
			端口号:
			协议:
				UPD:
				TCP:
		案例:
			1. 客户端给服务器端发送数据.
			2. 服务器端给客户端响应数据.
			3. 客户端和服务器端进行数据交互(字符流版).



今日具体内容:
1. 多线程简介:
	概述: 进程有多条执行路径, 合成为多线程.
		进程: 可执行文件(程序), 例如: .exe文件.
			//可以理解为是: 车
			
		线程: 进程的执行路径(执行单元).
			//可以理解为是: 车道
	
	
	多线程并行和多线程并发的区别:
		多线程并行: 
			多个线程同时执行. (前提, 需要多核CPU)
			
		多线程并发: 
			多个线程同时请求执行, 但是同一瞬间, CPU只能执行一个线程, 
			于是就安排这些线程交替执行, 因为时间间隔非常短, 我们看起来
			好像是同时执行的, 其实不是.



2. 多线程的实现方式:
	方式一: 继承Thread类的方式.
		步骤:
			A: 定义一个类(MyThread), 继承Thread类.
			B: 重写Thread#run().
			C: 把要执行的代码放入到run()中.
			D: 创建线程对象.
				MyThread mt = new MyThread();
			E: 开启线程.
				注意:
					1) 开启线程, 调用的是Thread#start()方法.
					   如果你调用的是run()方法, 那么只是普通的方法调用.
					2) 同一个线程对象不能重复开启, 否则会报: IllegalThreadStateException(非法的线程状态异常)

	方式二: 实现Runnable接口.
		步骤:
			A: 定义一个类(MyRunnable), 实现Runnable接口.
			B: 重写MyRunnable#run().
			C: 把要执行的代码放入到run()中.
			D: 创建Runnable接口的子类对象, 将其作为参数传入Thread类的构造方法, 创建线程对象.
			E: 开启线程.
				注意:
					1) 开启线程, 调用的是Thread#start()方法.
					   如果你调用的是run()方法, 那么只是普通的方法调用.
					2) 同一个线程对象不能重复开启, 否则会报: IllegalThreadStateException(非法的线程状态异常)
		
	
	方式三: 结合线程池使用, 实现Callable接口.		//目前了解即可.				

	
3. 卖票案例
	案例: 模拟卖票的案例.
		//需求: 有100张票, 分4个窗口卖.
		
		方式一: 继承Thread类的方式实现.
		
		
		方式二: 实现Runnable接口实现.
		
		
		出现的问题及解决方案:
			出现的问题:
				出现重复值:
				
				
				出现负数:
				
				
			解决方案:
				采用同步代码块解决.
	
	
	
4. Thread类中的成员总结
		构造方法:
			public Thread();
			public Thread(String name);
			public Thread(Runnable target);
			public Thread(Runnable target, String name);
		
		成员方法:
			public void run();						//里边记录的是多线程要执行的代码, 该方法会自动被start()方法调用.
			public void start();					//开启线程, 该方法会自动调用run().
			public String getName();				//获取当前正在执行的线程对象的名字.
			public void setName(String name);		//设置线程名
			public static Thread currentThread();	//获取当前正在执行的线程对象.
			public static void sleep(long millis);	//让线程休眠指定的时间, 单位是: 毫秒.

	
5. 多线程的生命周期
	
	
	
	
*****************************************************以下是: 网络编程*****************************************************
1. 网络编程简介
	概述: //也叫套接字编程, 也叫Socket编程.
		大白话版: 用来在不同的设备间进行数据传输的.
		专业版: 用来实现网络互联的 不同计算机上 运行的程序间 可以进行数据交换(交互).
	
	网络模型:	
		TCP/IP模型, 一共7层.
			物理层
			数据链路层
			传输层
			网络层
			表示层
			会话层
			应用层	
			
	三大要素:
		IP:	 
			概述: 设备(手机, 电脑, Ipad)在网络中的唯一标识.  
			
			组成: 网络(网关)号码  + 主机地址;		
					//192.168.109.67
			
			分类:
				城域网: 1 + 3	
					
				
				广域网: 2 + 2		
					
				
				局域网: 3 + 1
					
				
				
			两个特殊的IP:
				127.0.0.1:			本地回环(回路)地址,  写在哪台电脑上, 它就表示谁. 可以理解为: 是本机的意思.
				255.255.255.255:	广播地址.
				
			两个常用的DOS指令:
				ipconfig /all: 		可以查看你的IP地址的详细信息
				ping ip地址 -t:		测试网络连接(是否通畅)
		
			InetAddress: IP地址的包装类.
				String类型的IP				-->			IP地址对象
					public static InetAddress getByName(String hostOrIp);   //根据传入的主机名或者IP地址获取其对应的: IP地址对象.
				
				
				IP地址对象					-->			String类型的IP
					public String getHostAddress();			//根据IP地址对象, 获取其对应的String类型的ip.
		端口:
		
			概述: 程序在设备上的唯一标识.
			
			范围: 0~65535
			
			注意事项: 
				其中0~1024之间的端口号已经被系统占用了, 或者用作保留端口.
				你在自定义端口号的时候, 要规避这些范围的端口号. 
	
		协议:	//设备间通信的规则.
			UDP:	//群发消息.
				1. 面向无连接.
				2. 采用数据报包(DatagramPacket)发送数据, 每个包的大小不能超过: 64KB.
				3. 不安全(不可靠)协议.
				4. 效率相对较高.
				5. 不区分客户端和服务器端, 叫发送端和接收端.
			
			TCP:	//单聊
				1. 面向有连接(三次握手).
				2. 采用IO流发送数据, 理论上来讲,无数据大小限制.
				3. 安全(可靠)协议.
				4. 效率相对较低.
				5. 区分客户端和服务器端.
				
				
		网络通信的原理:
			网络通信也叫Socket通信, 通信两端都独有自己的Socket对象, 数据在两个Socket之间进行交互.
			//例如: 你给你的朋友打电话, 看起来好像是你和你朋友在聊天, 其实是两个手机在输出数据.
				
				
				
		此处以TCP举例, 来模拟数据传输的动作:
			客户端的代码:
				1. 创建客户端的Socket对象, 指定: 服务器端的IP, 指定端口号.
					public Socket(String ip,int port);
				2. 通过Socket#getInputStream(), getOutputStream()获取可以和服务器端相交互的流.
					public InputStream getInputStream();	//获取输入流对象, 可以读取服务器写过来的数据.
					public OutputStream getOutputStream();	//获取输出流对象, 可以往服务器端写数据.
				3. 释放资源.
			
			
			服务器端的代码:
				1. 创建服务器端的Socket对象(ServerSocket), 指定端口号.
					public ServerSocket(int port);
				2. 通过ServerSocket#accept()监听连接, 如果有客户端申请建立连接,
				   当服务器端交验完数据后, 如果数据合法, 就创建一个和该客户端相交互的 Socket对象.
				3. 通过Socket#getInputStream(), getOutputStream()获取可以和客户端相交互的流.
					public InputStream getInputStream();	//获取输入流对象, 可以读取客户端写过来的数据.
					public OutputStream getOutputStream();	//获取输出流对象, 可以往客户端写数据.
				4. 释放资源.
					
					
面试题:
	1. 多线程并行和多线程并发的区别? 

	2. Java程序是多线程的吗?
		是, 至少开启了 main线程(主线程), GC(垃圾回收线程).
	
	
	3. 线程的默认命名规则是什么?
		Thread-编号, 编号从0开始.
	
	4. 多线程执行的特点是什么?
		随机性, 延迟性. 原因是因为CPU在做着高效的切换.
	
	5. 多线程的两种实现方式的区别是什么?
		继承Thread类:
			好处: 代码相对比较简单. 	//因为是继承Thread类, 所以可以直接使用Thread类中的方法.
			弊端: 扩展性相对较差.		//因为已经继承Thread类了, 就不能继承别的类.
			
		实现Runnable接口:
			好处: 扩展性相对较强.
			弊端: 代码相对比较繁琐.
				//繁琐, 冗余, 复杂, 困难.
				
				//commons-io.jar  专门操作IO流的jar包.
	
	
	6. 多线程的生命周期是什么?
		官方解释:
			新建, 就绪, 运行(可能会发生阻塞), 死亡.
			
		加强版:
			新建, 就绪, 运行(可能会发生阻塞和等待), 死亡.
	
	
	7. 网络编程的三大要素是什么?
	
	8. 端口号的范围是多少?
		//想知道的: 哪个号段不要用.
	
	9. UDP协议和TCP协议的区别是什么?
		
	
	
	



